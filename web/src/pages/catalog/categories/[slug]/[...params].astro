---
export const prerender = false;

import BaseLayout from '@/web/src/layouts/BaseLayout.astro';
import { type Category } from '@/web/src/core/models/category';
import { getCategory } from '@/web/src/core/utils/live-collection-manager';
import Categories from '@/web/src/components/catalog/Categories.astro';
import Products from '@/web/src/components/catalog/Products.astro';
import CollectionFallback from '@/web/src/components/CollectionFallback.astro';
import getRouteParser from '@/web/src/core/utils/route-parser';
import { getSessionManager } from '@/web/src/core/utils/session-manager';
import { defaultSorting, type Sorting } from '@/web/src/core/models/sorting';
import { type Paging } from '@/web/src/core/models/paging';
import type { Filtering } from '@/web/src/core/models/filtering';
import CategoryDetails from '@/web/src/components/catalog/CategoryDetails.astro';
import { queryManager } from '@/web/src/core/services/queryManager';
import { fetchMeasurementUnits } from '@/web/src/core/services/queries/measurementUnits';
import { fetchDiscounts } from '@/web/src/core/services/queries/discounts';
import { fetchProductColors } from '@/web/src/core/services/queries/product-colors';
import type { CatalogReferences } from '@/web/src/core/models/catalog';
import { getCacheInfo } from '@/web/src/core/models/cache';
import { CacheKeys } from '@/web/src/core/const/cache';

const { slug, params } = Astro.params;

const parseRouteParams = (): { 
  sorting: Sorting | undefined, 
  paging: Paging | undefined,
  filtering: Filtering[]
} => {
  console.log("ðŸŒŽ ~ Category page ~ slug %s, params: %o", slug, params);
  const routeParser = getRouteParser(params);
  
  const sorting = routeParser.getCatalogSorting();
  console.log("ðŸŒŽ ~ Categories page ~ parsed sort", sorting);

  let paging = routeParser.getCatalogPaging();
  console.log("ðŸŒŽ ~ Category page ~ parse paging", paging);

  const filtering = routeParser.getCatalogFiltering();  
  console.log("ðŸŒŽ ~ Category page ~ parsed filters", filtering);

  return { sorting, paging, filtering };
}

const fetchCatalogReferences = async (): Promise<CatalogReferences | undefined> => {
  return await Promise.all([
    queryManager().fetch(
      () => fetchMeasurementUnits(),
      getCacheInfo(CacheKeys.MeasurementUnits),
    ), 
    queryManager().fetch(
      () => fetchDiscounts(), 
      getCacheInfo(CacheKeys.Discounts),
    ), 
    queryManager().fetch(
      () => fetchProductColors(),
      getCacheInfo(CacheKeys.ProductColors)
    ),
  ]).then((data) => {        
    if (data.some(x => x.error !== undefined)) {
      const errorMessage = data.reduce((acc, curr) => acc + `${curr.error !== undefined ? curr.error?.message + ", " : ""}`, "").slice(0, -2);
      console.error("~ Category page ~", errorMessage);  
      return undefined;
    }
    return {
      measurementUnits: data[0].data ?? [],
      discounts: data[1].data ?? [],
      productColors: data[2].data ?? [],
    }
  }).catch((err) => { 
    console.error("~ Category page ~ failed to load dictionaries (measurement units, discounts, product colors))", err);
    return undefined;
  });
}

const fetchCategory = async (): Promise<Category | undefined> => {
  let result: Category | undefined;
  try {
    if (slug !== undefined) result = await getCategory(slug);
  } catch(error) {
    console.error("ðŸ›‘ ~ Category page ~ failed to fetch category", error);
  }
  return result;
}

const sessionManager = getSessionManager(Astro.session);
const category = await fetchCategory();
if (category === undefined) {
  sessionManager.resetActiveCatalogItem();
  return Astro.redirect("/404");
}

const references = await fetchCatalogReferences();
if (references === undefined) {
  return Astro.redirect("/500");
}

sessionManager.setActiveCatalogItem({ 
  parentCategory: category?.parentSlug && category?.parentTitle ? 
    { slug: category?.parentSlug, title: category?.parentTitle } 
    : undefined, 
  category: { slug: category.slug, title: category.title }, 
  product: undefined
});

const { sorting, paging, filtering } = parseRouteParams();
const productsView = await sessionManager.getProductsView();
const newProductsView = {
    sorting: sorting !== undefined 
    ? sorting 
    : productsView?.sorting ?? defaultSorting, 
  filtering: filtering !== undefined && filtering.length > 0 
    ? filtering 
    : productsView?.filtering,
};
sessionManager.setProductsView(newProductsView);
//console.log("ðŸŒŽ ~ Categories page ~ set Session['productsView']", newProductsView);
---

<BaseLayout title=`ÐšÐ°Ñ‚Ð°Ð»Ð¾Ð³ - ${category?.title}`>
  <CategoryDetails item={category} />
  <Categories parentSlug={category?.slug} server:defer>
		<div slot="fallback" class="mx-3.5">
			<CollectionFallback />
		</div>
	</Categories>
	<Products categorySlug={category?.slug} references={references} sorting={newProductsView.sorting} paging={paging} filtering={newProductsView.filtering} server:defer>
		<div slot="fallback" class="mx-3.5">
			<CollectionFallback />
		</div>
	</Products>
</BaseLayout>