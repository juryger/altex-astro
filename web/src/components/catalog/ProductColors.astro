---
import { ColorDictionary } from '../../core/models/color';

interface Props {
  productId: number,
  colors?: number[],
  isDetailed?: boolean
}

const { productId, colors, isDetailed } = Astro.props;
console.log("üåé ~ ProductColors ~ colors", colors);

const spanSelectedColorName = "data-selected-color";
const titleColorOptions = "–¶–≤–µ—Ç:";
const noProductColors = "–ù–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ü–≤–µ—Ç–µ";
---

<product-colors data-selected_color={spanSelectedColorName}> 
  <div class:list={['flex', {'justify-start': isDetailed}, {'my-4': isDetailed}, {'justify-center': !isDetailed}]}>
    <span>{titleColorOptions}</span>
    <span data-selected-color class="pl-1"></span>
  </div>
  {colors && colors.length > 0 && 
    <div class:list={['flex', 'items-center', 'gap-3', 'my-1', {'justify-start' : isDetailed} , {'justify-center': !isDetailed}]}>
      {colors.sort().map((key, index) => {
        const metadata = ColorDictionary[key];
        return <input type="radio" name={"radio-color".concat(productId.toString())}
          checked={index == 0 ? "checked" : undefined} title={metadata.title} value={key}
          class="appearance-none rounded-full border-1 checked:outline-2 checked:outline-offset-2 checked:outline-gray-400 focus-visible:outline-4 focus-visible:outline-offset-4"
          class:list={[
            metadata.color, 
            metadata.border, 
            {'size-7': isDetailed}, 
            {'size-5' : !isDetailed}, 
          ]}
        />;
      })}
    </div>
  }
  {(!colors || colors?.length === 0) && 
    <div class:list={['flex', 'items-center', 'min-h-7', { 'justify-start': isDetailed }, {'justify-center': !isDetailed }]}>
      <span class="italic text-sm">{noProductColors}</span>
    </div>
  }
</product-colors>

<script>
  class ProductColors extends HTMLElement {
    colorHandlers: {
      [key: number]: (e: Event) => any;
    } = {};

    onColorSelect = (el: Element | null, title: string): any => {
      return (event: Event): void => {
        if (el !== null) el.innerHTML = title;
      };
    }
    
    connectedCallback() {
      const spanSelectedColorName = this.dataset.selected_color;
      const selectedColorTitleEl = this.querySelector(`[${spanSelectedColorName}]`);
      console.assert(selectedColorTitleEl !== null, "Cannot find span element for selected color: %s", spanSelectedColorName);

      const radioboxes = this.querySelectorAll('input[type=radio]');
      if (radioboxes.length > 0 && selectedColorTitleEl !== null) {
        selectedColorTitleEl.innerHTML = radioboxes[0].getAttribute("title") ?? "";
      }
      
      radioboxes.forEach((x: Element, index: number) => {
        this.colorHandlers[index] = this.onColorSelect(selectedColorTitleEl, x.getAttribute('title') ?? "");
        x.addEventListener('click', this.colorHandlers[index]);
      });
    }

    disconnectedCallback() {
      const radioboxes = this.querySelectorAll('input[type=radio]');
      radioboxes.forEach((x: Element, index: number) => {
        this.colorHandlers[index] && x.removeEventListener('click', this.colorHandlers[index]);
      });
    }
  }

  customElements.define('product-colors', ProductColors);
</script>