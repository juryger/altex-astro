---
import { Image } from 'astro:assets';
import type { CartItem } from '../../core/models/cart';

interface Props {
  item: CartItem,
}
const { item } = Astro.props;
const productsBlobStorageUrl = `${import.meta.env.PUBLIC_BLOB_STORAGE_PRODUCTS_URL}`;
---

<cart-item-details
  data-id={item.id} data-product_id={item.productId} data-title={item.title} data-available_colors={JSON.stringify(item.availableColors)} 
  data-price={item.price} data-whs_price1={item.whsPrice1} data-whs_price2={item.whsPrice2} 
  data-quatnity={item.quantity} data-color={item.color} data-image={item.image} data-slug={item.slug} 
>
  <div class="grid grid-cols-1 gap-2 sm:gap-6 sm:grid-cols-2 px-2 py-2">
    <div>
      {/* Product code */}
      <div class="flex flex-row justify-start">
        <span class="text-xs italic \">Артикул:</span>
      </div>
      {/* Gallery */}
      <figure class="aspect-square w-full object-cover group-hover:opacity-90 lg:aspect-auto min-h-[200px]">
        <Image src={productsBlobStorageUrl.concat("/", item.image)} alt={item.title} width="200" height="200" class="rounded-xl" />
      </figure>
    </div>
    <div class="px-2 py-2">
      <h1 class="font-bold text-lg mb-2">{item.title}</h1>
      {/* Available colors */}
      {/* Quantity input */}
      {/*
        <div class="flex flex-1 items-end justify-between text-sm">
          <p class="text-gray-500">Qty 1</p>
          <div class="flex">
            <button type="button" class="font-medium text-indigo-600 hover:text-indigo-500">Remove</button>
          </div>
        </div>
      */}
    </div>
  </div>
</cart-item-details>

<script>
  import { CartMessages } from "../../core/const/messages";
  import { parseCartItem } from "../../core/helpers/data-attributes-parser";
  import { AlertKind } from "../../core/models/alert";
  import type { CartItem } from "../../core/models/cart";
  import { addAlert } from "../../core/stores/alert-store";
  import { removeFromCart, updateCart } from "../../core/stores/cart-store";

  class CartItemDetails extends HTMLElement {
    private value: CartItem | undefined;
    private removeFromCartHandler: any | undefined;

    constructor() {
      super();
    }
    
    private onUpdateCart = (): any => {
      return (e: Event): void => {
        if (!this.value) {
          console.warn("~ CartItemDetails ~ cannot update cart as data attribute was not parsed properly.")
          return;
        }

        const selectedColorEl =  this.querySelector('input[type=radio]:checked');
        var selectedColor = selectedColorEl ? (selectedColorEl as HTMLInputElement).value : null;
        
        const radioboxes = this.querySelectorAll('input[type=radio]')
        if (!selectedColor && radioboxes.length > 0) {
          selectedColor = (radioboxes[0] as HTMLInputElement).value;
        }
        const color = selectedColor !== null ? parseInt(selectedColor, 10) : undefined;
        
        const inputQuantityName = this.dataset.input_quatnity;
        var quanityEl = this.querySelector(`input[name='${inputQuantityName}']`);
        console.assert(quanityEl !== null, "~ CartItemDetails ~ cannot find input element with name: %s", inputQuantityName);
        const quantity = quanityEl ? parseInt((quanityEl as HTMLInputElement).value) : 1;

        updateCart({ ...this.value, quantity, color });

        addAlert({ 
          kind: AlertKind.Info, 
          message: CartMessages.UpdatedInTheCart
        });
      }
    }

    private onRemoveFromCart = (): any => {
      return (e: Event): void => {
        if (!this.value) {
          console.warn("~ CartItemDetails ~ cannot remove product from the cart as it values was not parsed properly.")
          return;
        }
        
        removeFromCart(this.value.id);

        addAlert({ 
          kind: AlertKind.Info, 
          message: CartMessages.RemovedFromTheCart
        });
      }
    }

    connectedCallback() {
      this.value = parseCartItem(this.dataset);
      if (!this.value) {
        console.warn(`~ CartItemDetails ~ provided values of Cart Item via data attributes are not valid or complete.`);
        return;
      }

      this.removeFromCartHandler = this.onRemoveFromCart();
    }

    disconnectedCallback() {
      const btnRemoveFromCartName = this.dataset.btn_remove_from_cart;
      const button = this.querySelector(`button[name='${btnRemoveFromCartName}']`);
      this.removeFromCartHandler && button && button.removeEventListener('click', this.removeFromCartHandler);
    }
  }

  customElements.define('cart-item-details', CartItemDetails);
</script>